"""Custom S3 storage backend that routes media URLs through Django.

When MinIO runs inside a Kubernetes cluster (internal endpoint like
``http://minio.namespace.svc:9000``), the URLs generated by
``S3Boto3Storage`` are unreachable from the browser.

This module provides ``ProxiedS3Storage`` which overrides ``.url()`` to
return ``/media/<key>`` instead of the internal S3 endpoint.  A companion
view (``media_proxy_view``) streams the file from S3 through Django so
the browser always gets a valid, publicly-reachable URL via the Django
backend domain.

If ``AWS_S3_CUSTOM_DOMAIN`` is set (e.g. a public MinIO domain), the
base ``S3Boto3Storage`` already generates correct public URLs and no
proxy is needed.
"""
from __future__ import annotations

import logging
import mimetypes

from botocore.exceptions import (
    BotoCoreError,
    ClientError,
    ConnectionError as BotoConnectionError,
    EndpointConnectionError,
)
from django.conf import settings
from django.http import FileResponse, Http404, HttpResponseNotModified, JsonResponse
from django.utils.http import http_date
from storages.backends.s3boto3 import S3Boto3Storage

logger = logging.getLogger(__name__)


class ProxiedS3Storage(S3Boto3Storage):
    """S3 storage that generates ``/media/<key>`` URLs for the browser.

    This ensures media URLs always go through the Django backend,
    avoiding the need to expose MinIO publicly.  If
    ``AWS_S3_CUSTOM_DOMAIN`` is set, the parent class returns the
    public S3 URL directly (no proxy needed).

    Also applies ``AWS_S3_CONFIG`` (a ``botocore.config.Config``) if
    present in settings, so that connection/read timeouts and retry
    limits are honoured.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Apply botocore Config (timeouts, retries) if provided in settings.
        config = getattr(settings, 'AWS_S3_CONFIG', None)
        if config and hasattr(self, 'connection') is False:
            # django-storages >=1.14 reads config from settings automatically
            # via AWS_S3_CONFIG.  Older versions need manual patching.
            pass  # AWS_S3_CONFIG is picked up by django-storages automatically

    def url(self, name: str, parameters=None, expire=None, http_method=None):  # noqa: ARG002
        # If a public custom domain is configured, use the standard S3 URL.
        if getattr(settings, 'AWS_S3_CUSTOM_DOMAIN', ''):
            return super().url(name, parameters=parameters, expire=expire, http_method=http_method)
        # Otherwise return a path that goes through our media_proxy_view.
        clean = str(name).lstrip('/')
        media_url = getattr(settings, 'MEDIA_URL', '/media/')
        return f'{media_url}{clean}'


def media_proxy_view(request, path: str):
    """Stream a file from S3 storage through Django.

    Supports ``If-Modified-Since`` / ``Last-Modified`` caching and sets
    the correct ``Content-Type``.  Intended to be mounted at
    ``/media/<path:path>``.
    """
    from django.core.files.storage import default_storage

    if not default_storage.exists(path):
        raise Http404

    try:
        s3_file = default_storage.open(path, 'rb')
    except Exception:
        logger.exception('Failed to open S3 file: %s', path)
        raise Http404

    # Content type
    content_type, _ = mimetypes.guess_type(path)
    if not content_type:
        content_type = 'application/octet-stream'

    # Size — try to get it for Content-Length header
    try:
        size = default_storage.size(path)
    except Exception:
        size = None

    response = FileResponse(s3_file, content_type=content_type)

    if size is not None:
        response['Content-Length'] = size

    # Cache headers — let browsers cache media for 1 hour.
    response['Cache-Control'] = 'public, max-age=3600'

    # Last-Modified — let the browser send If-Modified-Since on revalidation.
    try:
        last_modified = default_storage.get_modified_time(path)
        response['Last-Modified'] = http_date(last_modified.timestamp())

        # Honour If-Modified-Since
        ims = request.META.get('HTTP_IF_MODIFIED_SINCE')
        if ims and last_modified:
            from django.utils.http import parse_http_date_safe
            ims_ts = parse_http_date_safe(ims)
            if ims_ts and last_modified.timestamp() <= ims_ts:
                s3_file.close()
                return HttpResponseNotModified()
    except Exception:
        pass  # Not all storage backends support get_modified_time

    return response
